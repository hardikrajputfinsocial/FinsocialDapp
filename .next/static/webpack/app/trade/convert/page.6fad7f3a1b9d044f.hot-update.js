"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/trade/convert/page",{

/***/ "(app-pages-browser)/./hooks/useWalletBalance.ts":
/*!***********************************!*\
  !*** ./hooks/useWalletBalance.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWalletBalance: () => (/* binding */ useWalletBalance)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/web3-provider.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/@ethersproject/units/lib.esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ useWalletBalance auto */ \n\n\n// Token contract addresses on Ethereum mainnet\nconst TOKEN_ADDRESSES = {\n    eth: 'native',\n    usdt: '0xdAC17F958D2ee523a2206206994597C13D831ec7',\n    usdc: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n    bnb: '0xB8c77482e45F1F44dE1745F52C74426C631bDD52',\n    sol: '0xD31a59c85aE9D8edEFeC411D448f90841571b89c',\n    btc: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599' // Wrapped BTC\n};\n// Hardcoded token decimals to avoid contract calls\nconst TOKEN_DECIMALS = {\n    eth: 18,\n    usdt: 6,\n    usdc: 6,\n    bnb: 18,\n    sol: 9,\n    btc: 8\n};\n// ABI for ERC20 token balanceOf function\nconst ERC20_ABI = [\n    'function balanceOf(address owner) view returns (uint256)',\n    'function decimals() view returns (uint8)'\n];\n// Exchange rates for demo purposes\nconst EXCHANGE_RATES = {\n    btc: {\n        eth: 15.23,\n        usdt: 43250.78,\n        usdc: 43245.65,\n        bnb: 112.45,\n        sol: 276.89\n    },\n    eth: {\n        btc: 0.0656,\n        usdt: 2845.32,\n        usdc: 2843.21,\n        bnb: 7.38,\n        sol: 18.21\n    },\n    usdt: {\n        btc: 0.000023,\n        eth: 0.00035,\n        usdc: 0.9998,\n        bnb: 0.0026,\n        sol: 0.0064\n    },\n    usdc: {\n        btc: 0.000023,\n        eth: 0.00035,\n        usdt: 1.0002,\n        bnb: 0.0026,\n        sol: 0.0064\n    },\n    bnb: {\n        btc: 0.0089,\n        eth: 0.1355,\n        usdt: 385.45,\n        usdc: 385.12,\n        sol: 2.47\n    },\n    sol: {\n        btc: 0.0036,\n        eth: 0.0549,\n        usdt: 156.23,\n        usdc: 156.08,\n        bnb: 0.405\n    }\n};\nfunction useWalletBalance() {\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [balances, setBalances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        btc: '0',\n        eth: '0',\n        usdt: '0',\n        usdc: '0',\n        bnb: '0',\n        sol: '0'\n    });\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Check if wallet is connected on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWalletBalance.useEffect\": ()=>{\n            const checkWalletConnection = {\n                \"useWalletBalance.useEffect.checkWalletConnection\": ()=>{\n                    const savedAddress = localStorage.getItem('walletAddress');\n                    if (savedAddress) {\n                        setWalletAddress(savedAddress);\n                        setIsConnected(true);\n                        fetchBalances(savedAddress);\n                    }\n                }\n            }[\"useWalletBalance.useEffect.checkWalletConnection\"];\n            checkWalletConnection();\n        }\n    }[\"useWalletBalance.useEffect\"], []);\n    // Function to get a provider\n    const getProvider = ()=>{\n        // Check if MetaMask is available\n        if ( true && window.ethereum) {\n            return new ethers__WEBPACK_IMPORTED_MODULE_2__.Web3Provider(window.ethereum);\n        }\n        // Fallback to Infura or other public provider\n        return new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider('https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161');\n    };\n    // Format balance with proper decimals\n    const formatBalance = (balance, decimals)=>{\n        return ethers__WEBPACK_IMPORTED_MODULE_4__.formatUnits(balance, decimals);\n    };\n    // Generate consistent mock balances based on wallet address\n    const generateMockBalances = (address)=>{\n        // Use the wallet address to generate deterministic balances\n        // This ensures the same address always shows the same balances\n        const addressSum = address.toLowerCase().split('').reduce((sum, char)=>sum + char.charCodeAt(0), 0);\n        const seed = addressSum / 1000;\n        return {\n            btc: (0.001 + seed * 0.025 % 0.1).toFixed(4),\n            eth: (0.1 + seed * 0.5 % 2).toFixed(4),\n            usdt: (100 + seed * 50 % 500).toFixed(2),\n            usdc: (100 + seed * 45 % 500).toFixed(2),\n            bnb: (0.5 + seed * 0.75 % 5).toFixed(3),\n            sol: (2 + seed * 1.5 % 10).toFixed(2)\n        };\n    };\n    // Fetch wallet balances - only fetch real ETH balance and use mock data for other tokens\n    const fetchBalances = async (address)=>{\n        if (!address) return;\n        setIsLoading(true);\n        try {\n            // Generate mock balances first as a base\n            const mockBalances = generateMockBalances(address);\n            let newBalances = {\n                ...mockBalances\n            };\n            // Only try to get real ETH balance from the blockchain\n            try {\n                const provider = getProvider();\n                const ethBalance = await provider.getBalance(address);\n                newBalances.eth = formatBalance(ethBalance, TOKEN_DECIMALS.eth);\n                console.log('Successfully fetched real ETH balance:', newBalances.eth);\n            } catch (err) {\n                console.error('Error fetching ETH balance:', err);\n            // Keep the mock ETH balance if there's an error\n            }\n            setBalances(newBalances);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.success('Wallet balances updated');\n        } catch (error) {\n            console.error('Error in fetchBalances:', error);\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error('Failed to fetch wallet balances');\n            // Fall back to mock data if there's a critical error\n            const mockBalances = generateMockBalances(address);\n            setBalances(mockBalances);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Get exchange rate between two coins\n    const getExchangeRate = (fromCoin, toCoin)=>{\n        var _EXCHANGE_RATES_fromCoin;\n        if (fromCoin === toCoin) return 1;\n        return ((_EXCHANGE_RATES_fromCoin = EXCHANGE_RATES[fromCoin]) === null || _EXCHANGE_RATES_fromCoin === void 0 ? void 0 : _EXCHANGE_RATES_fromCoin[toCoin]) || 0;\n    };\n    // Calculate conversion amount\n    const calculateConversion = (fromCoin, toCoin, amount)=>{\n        const rate = getExchangeRate(fromCoin, toCoin);\n        return amount * rate;\n    };\n    return {\n        isConnected,\n        walletAddress,\n        balances,\n        isLoading,\n        fetchBalances,\n        getExchangeRate,\n        calculateConversion\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVdhbGxldEJhbGFuY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztzRUFFNEM7QUFDYjtBQUNDO0FBY2hDLCtDQUErQztBQUMvQyxNQUFNSSxrQkFBNkM7SUFDakRDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLEtBQUs7SUFDTEMsS0FBSztJQUNMQyxLQUFLLDZDQUE4QyxjQUFjO0FBQ25FO0FBRUEsbURBQW1EO0FBQ25ELE1BQU1DLGlCQUE0QztJQUNoRE4sS0FBSztJQUNMQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsS0FBSztJQUNMQyxLQUFLO0lBQ0xDLEtBQUs7QUFDUDtBQUVBLHlDQUF5QztBQUN6QyxNQUFNRSxZQUFZO0lBQ2hCO0lBQ0E7Q0FDRDtBQUVELG1DQUFtQztBQUNuQyxNQUFNQyxpQkFBK0Q7SUFDbkVILEtBQUs7UUFBRUwsS0FBSztRQUFPQyxNQUFNO1FBQVVDLE1BQU07UUFBVUMsS0FBSztRQUFRQyxLQUFLO0lBQU87SUFDNUVKLEtBQUs7UUFBRUssS0FBSztRQUFRSixNQUFNO1FBQVNDLE1BQU07UUFBU0MsS0FBSztRQUFNQyxLQUFLO0lBQU07SUFDeEVILE1BQU07UUFBRUksS0FBSztRQUFVTCxLQUFLO1FBQVNFLE1BQU07UUFBUUMsS0FBSztRQUFRQyxLQUFLO0lBQU87SUFDNUVGLE1BQU07UUFBRUcsS0FBSztRQUFVTCxLQUFLO1FBQVNDLE1BQU07UUFBUUUsS0FBSztRQUFRQyxLQUFLO0lBQU87SUFDNUVELEtBQUs7UUFBRUUsS0FBSztRQUFRTCxLQUFLO1FBQVFDLE1BQU07UUFBUUMsTUFBTTtRQUFRRSxLQUFLO0lBQUs7SUFDdkVBLEtBQUs7UUFBRUMsS0FBSztRQUFRTCxLQUFLO1FBQVFDLE1BQU07UUFBUUMsTUFBTTtRQUFRQyxLQUFLO0lBQU07QUFDMUU7QUFFTyxTQUFTTTtJQUNkLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHaEIsK0NBQVFBLENBQVU7SUFDeEQsTUFBTSxDQUFDaUIsZUFBZUMsaUJBQWlCLEdBQUdsQiwrQ0FBUUEsQ0FBUztJQUMzRCxNQUFNLENBQUNtQixVQUFVQyxZQUFZLEdBQUdwQiwrQ0FBUUEsQ0FBZTtRQUNyRFUsS0FBSztRQUNMTCxLQUFLO1FBQ0xDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxLQUFLO1FBQ0xDLEtBQUs7SUFDUDtJQUNBLE1BQU0sQ0FBQ1ksV0FBV0MsYUFBYSxHQUFHdEIsK0NBQVFBLENBQVU7SUFFcEQsd0NBQXdDO0lBQ3hDQyxnREFBU0E7c0NBQUM7WUFDUixNQUFNc0I7b0VBQXdCO29CQUM1QixNQUFNQyxlQUFlQyxhQUFhQyxPQUFPLENBQUM7b0JBQzFDLElBQUlGLGNBQWM7d0JBQ2hCTixpQkFBaUJNO3dCQUNqQlIsZUFBZTt3QkFDZlcsY0FBY0g7b0JBQ2hCO2dCQUNGOztZQUVBRDtRQUNGO3FDQUFHLEVBQUU7SUFFTCw2QkFBNkI7SUFDN0IsTUFBTUssY0FBYztRQUNsQixpQ0FBaUM7UUFDakMsSUFBSSxLQUE2QixJQUFJQyxPQUFPQyxRQUFRLEVBQUU7WUFDcEQsT0FBTyxJQUFJM0IsZ0RBQTZCLENBQUMwQixPQUFPQyxRQUFRO1FBQzFEO1FBRUEsOENBQThDO1FBQzlDLE9BQU8sSUFBSTNCLG1EQUFnQyxDQUFDO0lBQzlDO0lBRUEsc0NBQXNDO0lBQ3RDLE1BQU0rQixnQkFBZ0IsQ0FBQ0MsU0FBMkJDO1FBQ2hELE9BQU9qQywrQ0FBd0IsQ0FBQ2dDLFNBQVNDO0lBQzNDO0lBRUEsNERBQTREO0lBQzVELE1BQU1HLHVCQUF1QixDQUFDQztRQUM1Qiw0REFBNEQ7UUFDNUQsK0RBQStEO1FBQy9ELE1BQU1DLGFBQWFELFFBQ2hCRSxXQUFXLEdBQ1hDLEtBQUssQ0FBQyxJQUNOQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsT0FBU0QsTUFBTUMsS0FBS0MsVUFBVSxDQUFDLElBQUk7UUFFbkQsTUFBTUMsT0FBT1AsYUFBYTtRQUUxQixPQUFPO1lBQ0wvQixLQUFLLENBQUMsUUFBUSxPQUFRLFFBQVMsR0FBRSxFQUFHdUMsT0FBTyxDQUFDO1lBQzVDNUMsS0FBSyxDQUFDLE1BQU0sT0FBUSxNQUFPLEdBQUc0QyxPQUFPLENBQUM7WUFDdEMzQyxNQUFNLENBQUMsTUFBTSxPQUFRLEtBQU0sR0FBRSxFQUFHMkMsT0FBTyxDQUFDO1lBQ3hDMUMsTUFBTSxDQUFDLE1BQU0sT0FBUSxLQUFNLEdBQUUsRUFBRzBDLE9BQU8sQ0FBQztZQUN4Q3pDLEtBQUssQ0FBQyxNQUFNLE9BQVEsT0FBUSxHQUFHeUMsT0FBTyxDQUFDO1lBQ3ZDeEMsS0FBSyxDQUFDLElBQUksT0FBUSxNQUFPLEVBQUMsRUFBR3dDLE9BQU8sQ0FBQztRQUN2QztJQUNGO0lBRUEseUZBQXlGO0lBQ3pGLE1BQU10QixnQkFBZ0IsT0FBT2E7UUFDM0IsSUFBSSxDQUFDQSxTQUFTO1FBRWRsQixhQUFhO1FBQ2IsSUFBSTtZQUNGLHlDQUF5QztZQUN6QyxNQUFNNEIsZUFBZVgscUJBQXFCQztZQUMxQyxJQUFJVyxjQUE0QjtnQkFBRSxHQUFHRCxZQUFZO1lBQUM7WUFFbEQsdURBQXVEO1lBQ3ZELElBQUk7Z0JBQ0YsTUFBTUUsV0FBV3hCO2dCQUNqQixNQUFNeUIsYUFBYSxNQUFNRCxTQUFTRSxVQUFVLENBQUNkO2dCQUM3Q1csWUFBWTlDLEdBQUcsR0FBRzZCLGNBQWNtQixZQUFZMUMsZUFBZU4sR0FBRztnQkFDOURrRCxRQUFRQyxHQUFHLENBQUMsMENBQTBDTCxZQUFZOUMsR0FBRztZQUN2RSxFQUFFLE9BQU9vRCxLQUFLO2dCQUNaRixRQUFRRyxLQUFLLENBQUMsK0JBQStCRDtZQUM3QyxnREFBZ0Q7WUFDbEQ7WUFFQXJDLFlBQVkrQjtZQUNaakQseUNBQUtBLENBQUN5RCxPQUFPLENBQUM7UUFDaEIsRUFBRSxPQUFPRCxPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQywyQkFBMkJBO1lBQ3pDeEQseUNBQUtBLENBQUN3RCxLQUFLLENBQUM7WUFFWixxREFBcUQ7WUFDckQsTUFBTVIsZUFBZVgscUJBQXFCQztZQUMxQ3BCLFlBQVk4QjtRQUNkLFNBQVU7WUFDUjVCLGFBQWE7UUFDZjtJQUNGO0lBRUEsc0NBQXNDO0lBQ3RDLE1BQU1zQyxrQkFBa0IsQ0FBQ0MsVUFBa0JDO1lBRWxDakQ7UUFEUCxJQUFJZ0QsYUFBYUMsUUFBUSxPQUFPO1FBQ2hDLE9BQU9qRCxFQUFBQSwyQkFBQUEsY0FBYyxDQUFDZ0QsU0FBUyxjQUF4QmhELCtDQUFBQSx3QkFBMEIsQ0FBQ2lELE9BQU8sS0FBSTtJQUMvQztJQUVBLDhCQUE4QjtJQUM5QixNQUFNQyxzQkFBc0IsQ0FBQ0YsVUFBa0JDLFFBQWdCRTtRQUM3RCxNQUFNQyxPQUFPTCxnQkFBZ0JDLFVBQVVDO1FBQ3ZDLE9BQU9FLFNBQVNDO0lBQ2xCO0lBRUEsT0FBTztRQUNMbEQ7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQU07UUFDQWlDO1FBQ0FHO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiRDpcXHByb2pcXGZpbnNvXFxwcm9kbXZwXFxGaW5zb2NpYWxEYXBwXFxob29rc1xcdXNlV2FsbGV0QmFsYW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5cbi8vIEFkZCB0eXBlIGRlY2xhcmF0aW9uIGZvciB3aW5kb3cuZXRoZXJldW1cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgZXRoZXJldW0/OiBhbnk7XG4gIH1cbn1cblxuLy8gRGVmaW5lIGEgdHlwZSBmb3IgY29pbiBiYWxhbmNlc1xudHlwZSBDb2luQmFsYW5jZXMgPSB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZztcbn07XG5cbi8vIFRva2VuIGNvbnRyYWN0IGFkZHJlc3NlcyBvbiBFdGhlcmV1bSBtYWlubmV0XG5jb25zdCBUT0tFTl9BRERSRVNTRVM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIGV0aDogJ25hdGl2ZScsIC8vIEVUSCBpcyB0aGUgbmF0aXZlIHRva2VuXG4gIHVzZHQ6ICcweGRBQzE3Rjk1OEQyZWU1MjNhMjIwNjIwNjk5NDU5N0MxM0Q4MzFlYzcnLCAvLyBUZXRoZXIgVVNEXG4gIHVzZGM6ICcweEEwYjg2OTkxYzYyMThiMzZjMWQxOUQ0YTJlOUViMGNFMzYwNmVCNDgnLCAvLyBVU0QgQ29pblxuICBibmI6ICcweEI4Yzc3NDgyZTQ1RjFGNDRkRTE3NDVGNTJDNzQ0MjZDNjMxYkRENTInLCAvLyBCTkIgb24gRXRoZXJldW1cbiAgc29sOiAnMHhEMzFhNTljODVhRTlEOGVkRUZlQzQxMUQ0NDhmOTA4NDE1NzFiODljJywgLy8gV3JhcHBlZCBTT0wgb24gRXRoZXJldW1cbiAgYnRjOiAnMHgyMjYwRkFDNUU1NTQyYTc3M0FhNDRmQkNmZURmN0MxOTNiYzJDNTk5JyAgLy8gV3JhcHBlZCBCVENcbn07XG5cbi8vIEhhcmRjb2RlZCB0b2tlbiBkZWNpbWFscyB0byBhdm9pZCBjb250cmFjdCBjYWxsc1xuY29uc3QgVE9LRU5fREVDSU1BTFM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gIGV0aDogMTgsXG4gIHVzZHQ6IDYsXG4gIHVzZGM6IDYsXG4gIGJuYjogMTgsXG4gIHNvbDogOSxcbiAgYnRjOiA4XG59O1xuXG4vLyBBQkkgZm9yIEVSQzIwIHRva2VuIGJhbGFuY2VPZiBmdW5jdGlvblxuY29uc3QgRVJDMjBfQUJJID0gW1xuICAnZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIpIHZpZXcgcmV0dXJucyAodWludDI1NiknLFxuICAnZnVuY3Rpb24gZGVjaW1hbHMoKSB2aWV3IHJldHVybnMgKHVpbnQ4KSdcbl07XG5cbi8vIEV4Y2hhbmdlIHJhdGVzIGZvciBkZW1vIHB1cnBvc2VzXG5jb25zdCBFWENIQU5HRV9SQVRFUzogeyBba2V5OiBzdHJpbmddOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9IH0gPSB7XG4gIGJ0YzogeyBldGg6IDE1LjIzLCB1c2R0OiA0MzI1MC43OCwgdXNkYzogNDMyNDUuNjUsIGJuYjogMTEyLjQ1LCBzb2w6IDI3Ni44OSB9LFxuICBldGg6IHsgYnRjOiAwLjA2NTYsIHVzZHQ6IDI4NDUuMzIsIHVzZGM6IDI4NDMuMjEsIGJuYjogNy4zOCwgc29sOiAxOC4yMSB9LFxuICB1c2R0OiB7IGJ0YzogMC4wMDAwMjMsIGV0aDogMC4wMDAzNSwgdXNkYzogMC45OTk4LCBibmI6IDAuMDAyNiwgc29sOiAwLjAwNjQgfSxcbiAgdXNkYzogeyBidGM6IDAuMDAwMDIzLCBldGg6IDAuMDAwMzUsIHVzZHQ6IDEuMDAwMiwgYm5iOiAwLjAwMjYsIHNvbDogMC4wMDY0IH0sXG4gIGJuYjogeyBidGM6IDAuMDA4OSwgZXRoOiAwLjEzNTUsIHVzZHQ6IDM4NS40NSwgdXNkYzogMzg1LjEyLCBzb2w6IDIuNDcgfSxcbiAgc29sOiB7IGJ0YzogMC4wMDM2LCBldGg6IDAuMDU0OSwgdXNkdDogMTU2LjIzLCB1c2RjOiAxNTYuMDgsIGJuYjogMC40MDUgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVdhbGxldEJhbGFuY2UoKSB7XG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbd2FsbGV0QWRkcmVzcywgc2V0V2FsbGV0QWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmc+KCcnKTtcbiAgY29uc3QgW2JhbGFuY2VzLCBzZXRCYWxhbmNlc10gPSB1c2VTdGF0ZTxDb2luQmFsYW5jZXM+KHtcbiAgICBidGM6ICcwJyxcbiAgICBldGg6ICcwJyxcbiAgICB1c2R0OiAnMCcsXG4gICAgdXNkYzogJzAnLFxuICAgIGJuYjogJzAnLFxuICAgIHNvbDogJzAnXG4gIH0pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8vIENoZWNrIGlmIHdhbGxldCBpcyBjb25uZWN0ZWQgb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjaGVja1dhbGxldENvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCBzYXZlZEFkZHJlc3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsbGV0QWRkcmVzcycpO1xuICAgICAgaWYgKHNhdmVkQWRkcmVzcykge1xuICAgICAgICBzZXRXYWxsZXRBZGRyZXNzKHNhdmVkQWRkcmVzcyk7XG4gICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICBmZXRjaEJhbGFuY2VzKHNhdmVkQWRkcmVzcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrV2FsbGV0Q29ubmVjdGlvbigpO1xuICB9LCBbXSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gZ2V0IGEgcHJvdmlkZXJcbiAgY29uc3QgZ2V0UHJvdmlkZXIgPSAoKSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgTWV0YU1hc2sgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgcmV0dXJuIG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBJbmZ1cmEgb3Igb3RoZXIgcHVibGljIHByb3ZpZGVyXG4gICAgcmV0dXJuIG5ldyBldGhlcnMucHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcignaHR0cHM6Ly9tYWlubmV0LmluZnVyYS5pby92My85YWEzZDk1YjNiYzQ0MGZhODhlYTEyZWFhNDQ1NjE2MScpO1xuICB9O1xuXG4gIC8vIEZvcm1hdCBiYWxhbmNlIHdpdGggcHJvcGVyIGRlY2ltYWxzXG4gIGNvbnN0IGZvcm1hdEJhbGFuY2UgPSAoYmFsYW5jZTogZXRoZXJzLkJpZ051bWJlciwgZGVjaW1hbHM6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIGV0aGVycy51dGlscy5mb3JtYXRVbml0cyhiYWxhbmNlLCBkZWNpbWFscyk7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgY29uc2lzdGVudCBtb2NrIGJhbGFuY2VzIGJhc2VkIG9uIHdhbGxldCBhZGRyZXNzXG4gIGNvbnN0IGdlbmVyYXRlTW9ja0JhbGFuY2VzID0gKGFkZHJlc3M6IHN0cmluZyk6IENvaW5CYWxhbmNlcyA9PiB7XG4gICAgLy8gVXNlIHRoZSB3YWxsZXQgYWRkcmVzcyB0byBnZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGJhbGFuY2VzXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBzYW1lIGFkZHJlc3MgYWx3YXlzIHNob3dzIHRoZSBzYW1lIGJhbGFuY2VzXG4gICAgY29uc3QgYWRkcmVzc1N1bSA9IGFkZHJlc3NcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAucmVkdWNlKChzdW0sIGNoYXIpID0+IHN1bSArIGNoYXIuY2hhckNvZGVBdCgwKSwgMCk7XG4gICAgXG4gICAgY29uc3Qgc2VlZCA9IGFkZHJlc3NTdW0gLyAxMDAwO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBidGM6ICgwLjAwMSArIChzZWVkICogMC4wMjUpICUgMC4xKS50b0ZpeGVkKDQpLFxuICAgICAgZXRoOiAoMC4xICsgKHNlZWQgKiAwLjUpICUgMikudG9GaXhlZCg0KSxcbiAgICAgIHVzZHQ6ICgxMDAgKyAoc2VlZCAqIDUwKSAlIDUwMCkudG9GaXhlZCgyKSxcbiAgICAgIHVzZGM6ICgxMDAgKyAoc2VlZCAqIDQ1KSAlIDUwMCkudG9GaXhlZCgyKSxcbiAgICAgIGJuYjogKDAuNSArIChzZWVkICogMC43NSkgJSA1KS50b0ZpeGVkKDMpLFxuICAgICAgc29sOiAoMiArIChzZWVkICogMS41KSAlIDEwKS50b0ZpeGVkKDIpXG4gICAgfTtcbiAgfTtcbiAgXG4gIC8vIEZldGNoIHdhbGxldCBiYWxhbmNlcyAtIG9ubHkgZmV0Y2ggcmVhbCBFVEggYmFsYW5jZSBhbmQgdXNlIG1vY2sgZGF0YSBmb3Igb3RoZXIgdG9rZW5zXG4gIGNvbnN0IGZldGNoQmFsYW5jZXMgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFhZGRyZXNzKSByZXR1cm47XG4gICAgXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBHZW5lcmF0ZSBtb2NrIGJhbGFuY2VzIGZpcnN0IGFzIGEgYmFzZVxuICAgICAgY29uc3QgbW9ja0JhbGFuY2VzID0gZ2VuZXJhdGVNb2NrQmFsYW5jZXMoYWRkcmVzcyk7XG4gICAgICBsZXQgbmV3QmFsYW5jZXM6IENvaW5CYWxhbmNlcyA9IHsgLi4ubW9ja0JhbGFuY2VzIH07XG4gICAgICBcbiAgICAgIC8vIE9ubHkgdHJ5IHRvIGdldCByZWFsIEVUSCBiYWxhbmNlIGZyb20gdGhlIGJsb2NrY2hhaW5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgY29uc3QgZXRoQmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UoYWRkcmVzcyk7XG4gICAgICAgIG5ld0JhbGFuY2VzLmV0aCA9IGZvcm1hdEJhbGFuY2UoZXRoQmFsYW5jZSwgVE9LRU5fREVDSU1BTFMuZXRoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBmZXRjaGVkIHJlYWwgRVRIIGJhbGFuY2U6JywgbmV3QmFsYW5jZXMuZXRoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBFVEggYmFsYW5jZTonLCBlcnIpO1xuICAgICAgICAvLyBLZWVwIHRoZSBtb2NrIEVUSCBiYWxhbmNlIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0QmFsYW5jZXMobmV3QmFsYW5jZXMpO1xuICAgICAgdG9hc3Quc3VjY2VzcygnV2FsbGV0IGJhbGFuY2VzIHVwZGF0ZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZmV0Y2hCYWxhbmNlczonLCBlcnJvcik7XG4gICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIGZldGNoIHdhbGxldCBiYWxhbmNlcycpO1xuICAgICAgXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gbW9jayBkYXRhIGlmIHRoZXJlJ3MgYSBjcml0aWNhbCBlcnJvclxuICAgICAgY29uc3QgbW9ja0JhbGFuY2VzID0gZ2VuZXJhdGVNb2NrQmFsYW5jZXMoYWRkcmVzcyk7XG4gICAgICBzZXRCYWxhbmNlcyhtb2NrQmFsYW5jZXMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBHZXQgZXhjaGFuZ2UgcmF0ZSBiZXR3ZWVuIHR3byBjb2luc1xuICBjb25zdCBnZXRFeGNoYW5nZVJhdGUgPSAoZnJvbUNvaW46IHN0cmluZywgdG9Db2luOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGlmIChmcm9tQ29pbiA9PT0gdG9Db2luKSByZXR1cm4gMTtcbiAgICByZXR1cm4gRVhDSEFOR0VfUkFURVNbZnJvbUNvaW5dPy5bdG9Db2luXSB8fCAwO1xuICB9O1xuXG4gIC8vIENhbGN1bGF0ZSBjb252ZXJzaW9uIGFtb3VudFxuICBjb25zdCBjYWxjdWxhdGVDb252ZXJzaW9uID0gKGZyb21Db2luOiBzdHJpbmcsIHRvQ29pbjogc3RyaW5nLCBhbW91bnQ6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgY29uc3QgcmF0ZSA9IGdldEV4Y2hhbmdlUmF0ZShmcm9tQ29pbiwgdG9Db2luKTtcbiAgICByZXR1cm4gYW1vdW50ICogcmF0ZTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGlzQ29ubmVjdGVkLFxuICAgIHdhbGxldEFkZHJlc3MsXG4gICAgYmFsYW5jZXMsXG4gICAgaXNMb2FkaW5nLFxuICAgIGZldGNoQmFsYW5jZXMsXG4gICAgZ2V0RXhjaGFuZ2VSYXRlLFxuICAgIGNhbGN1bGF0ZUNvbnZlcnNpb25cbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInRvYXN0IiwiZXRoZXJzIiwiVE9LRU5fQUREUkVTU0VTIiwiZXRoIiwidXNkdCIsInVzZGMiLCJibmIiLCJzb2wiLCJidGMiLCJUT0tFTl9ERUNJTUFMUyIsIkVSQzIwX0FCSSIsIkVYQ0hBTkdFX1JBVEVTIiwidXNlV2FsbGV0QmFsYW5jZSIsImlzQ29ubmVjdGVkIiwic2V0SXNDb25uZWN0ZWQiLCJ3YWxsZXRBZGRyZXNzIiwic2V0V2FsbGV0QWRkcmVzcyIsImJhbGFuY2VzIiwic2V0QmFsYW5jZXMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJjaGVja1dhbGxldENvbm5lY3Rpb24iLCJzYXZlZEFkZHJlc3MiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZmV0Y2hCYWxhbmNlcyIsImdldFByb3ZpZGVyIiwid2luZG93IiwiZXRoZXJldW0iLCJwcm92aWRlcnMiLCJXZWIzUHJvdmlkZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJmb3JtYXRCYWxhbmNlIiwiYmFsYW5jZSIsImRlY2ltYWxzIiwidXRpbHMiLCJmb3JtYXRVbml0cyIsImdlbmVyYXRlTW9ja0JhbGFuY2VzIiwiYWRkcmVzcyIsImFkZHJlc3NTdW0iLCJ0b0xvd2VyQ2FzZSIsInNwbGl0IiwicmVkdWNlIiwic3VtIiwiY2hhciIsImNoYXJDb2RlQXQiLCJzZWVkIiwidG9GaXhlZCIsIm1vY2tCYWxhbmNlcyIsIm5ld0JhbGFuY2VzIiwicHJvdmlkZXIiLCJldGhCYWxhbmNlIiwiZ2V0QmFsYW5jZSIsImNvbnNvbGUiLCJsb2ciLCJlcnIiLCJlcnJvciIsInN1Y2Nlc3MiLCJnZXRFeGNoYW5nZVJhdGUiLCJmcm9tQ29pbiIsInRvQ29pbiIsImNhbGN1bGF0ZUNvbnZlcnNpb24iLCJhbW91bnQiLCJyYXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useWalletBalance.ts\n"));

/***/ })

});